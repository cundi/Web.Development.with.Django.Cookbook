# Chapter 2. Database Structure 第二张数据库结构

In this chapter, we will cover the following topics:  

本章，我们覆盖了以下主题：  

- Using model mixins
- Creating a model mixin with URL-related methods
- Creating a model mixin to handle creation and modification dates
- Creating a model mixin to take care of meta tags
- Creating a model mixin to handle generic relations
- Handling multilingual fields
- Using migrations
- Switching from South migrations to Django migrations
- Changing a foreign key to the many-to-many field


- 使用模型Mixin
- 创建一个拥有相对URL方法的模型Mixin
- 创建一个能够处理日期的创建和修改的模型Minix
- 创建一个可以处理元标签的模型Minxin
- 创建一个处理通用关系的模型Mixin
- 处理多语言字段
- 应用迁移
- 从South的migration切换到Django的migration
- 改变一个关联到多对多字段到外键

## Introduction 引言

When you start a new app, the first thing to do is create the models that represent your database structure. We are assuming that you have previously created Django apps or at least, you have read and understood the official Django tutorial. In this chapter, we will see a few interesting techniques that make your database structure consistent throughout different apps in your project. Then, we will see how to create custom model fields in order to handle internationalization of your data in the database. At the end of the chapter, we will see how to use migrations to change your database structure in the process of development.  

当你开始编写一个新应用时，要做的第一件事就是创建代表数据库结构的模型。我们假设你在之前你已经创建了Django应用，至少你阅读过并理解了Django官方教程。本章，我们可以看到一些有趣的能让你项目中的不同应用保持数据库结构一致性的技术。然后我们可以看到如何创建自定义模型字段以便处理数据库中的国际化数据。在章节的最后，我们可以看到如何使用迁移在开发阶段改变数据库结构。  

## Using model mixins 使用模型mixin

In object-oriented languages, such as Python, a mixin class can be viewed as an interface with implemented features. When a model extends a mixin, it implements the interface and includes all its fields, properties, and methods. Mixins in Django models can be used when you want to reuse the generic functionalities in different models multiple times.  

在面相对象语言中，比如Python，mixin类可以看作是一个实现功能的借口。当模型扩展了一个mixin，它便实现了接口，包括所有mixin的全部字段，属性，和方法。Django模型的Mixin可以用在当你想要在不同的模型中多次重复使用通用功能时。  

### Getting ready 准备工作

First, you will need to create reusable mixins. Some typical examples of mixins are given later in this chapter. A good place to keep your model mixins is in the `utils` module.  

首先，你需要创建可重复使用的mixin。一些mixin的典型例子会在本章稍后给出。一个存放模型mixin的好地方就是`utils`模块。  

>### Tip
>If you create a reusable app that you will share with others, keep the model mixins in the reusable app, for example, in the base.py file.  

>### 提示
>如果你要创建一个和其他人分享的可重复使用的应用，请将模型mixin放到可重复使用的应用中，例如，base.py

## Using model mixins 使用模型Mixin

In object-oriented languages, such as Python, a mixin class can be viewed as an interface with implemented features. When a model extends a mixin, it implements the interface and includes all its fields, properties, and methods. Mixins in Django models can be used when you want to reuse the generic functionalities in different models multiple times.  

在像Python面向对象语言中，minxin类可以看作是一个拥有已实现功能的接口。当模型扩展为mixin，它可以实现接口以及所有自身所有的字段、特性、和方法。Django模型的Mixin可以多次地在不同的模型中重复使用通用功能。  

### Getting ready 准备工作

First, you will need to create reusable mixins. Some typical examples of mixins are given later in this chapter. A good place to keep your model mixins is in the `utils` module.  

首先，你需要创建可被重复使用的mixin。一些典型的mixin例子会在本章后面给出。

>### Tip 提示
>If you create a reusable app that you will share with others, keep the model mixins in the reusable app, for example, in the base.py file.  

如果你创建一个和其他人分享的重复使用的应用，可以将模型mixin放到重复使用的应用中，比如，放到文件base.py。  

### How to do it…
Open the models.py file of any Django app, where you want to use the mixins and type the following code:  

打开任意一个Django应用中的models.py文件，在这个文件中你需要使用mixin，并输入以下代码：  

```python
# demo_app/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import python_2_unicode_compatible
from utils.models import UrlMixin
from utils.models import CreationModificationMixin
from utils.models import MetaTagsMixin


@python_2_unicode_compatible
class Idea(UrlMixin, CreationModificationMixin, MetaTagsMixin):
  title = models.CharField(_("Title"), max_length=200)
  content = models.TextField(_("Content"))

    class Meta:
    verbose_name = _("Idea")
    verbose_name_plural = _("Ideas")

    def __str__(self):
    return self.title
```

### How it works… 实现原理
Django model inheritance supports three types of inheritance: abstract base classes, multi-table inheritance, and proxy models. Model mixins are abstract model classes with specified fields, properties, and methods. When you create a model such as Idea, as shown in the preceding example, it inherits all the features from UrlMixin, CreationModificationMixin, and MetaTagsMixin. All the fields of the abstract classes are saved in the same database table as the fields of the extending model. In the following recipes, you will learn how to define your model mixins.  

Django模型即成支持三种类型的继承：抽象基类，多表继承，以及代理模型。模型Mixin是指定了字段、特性和方法的抽象基类。当你依照这个观念来创建模型，就像在之前例子中那样，它降从UrlMixin、CreationModificationMixin, 和 MetaTagsMixin继承所有的功能。抽象基类的所有字段都保存在相同数据库表中，并作为扩展模型的字段。在下面的做法中，你会学习到如何定义自己的模型mixin。  

Note that we are using the `@python_2_unicode_compatible` decorator for our Idea model. As you might remember from the Making your code compatible with both Python 2.7 and Python 3 recipe in Chapter 1, Getting Started with Django 1.8, it's purpose is to make the `__str__()` method compatible with Unicode for both the following Python versions: 2.7 and 3.  

注意我们对Idea模型应用了装饰器`@python_2_unicode_compatible`。也许你还记得来自第一章Django 1.8入门中的能够让代码同时兼容Python2.7 和Python3的技巧，它的目的是让`__str__()`方法对以下两种Python版本同时兼容于Unicode。  

### There's more… 更多内容

To learn more about the different types of model inheritance, refer to the official Django documentation available at https://docs.djangoproject.com/en/1.8/topics/db/models/#model-inheritance.  

想要学些更多关于模型实例的内容，请参考Django文档https://docs.djangoproject.com/en/1.8/topics/db/models/#model-inheritance.  

### See also 参见

- The Making your code compatible with both Python 2.7 and Python 3 recipe in Chapter 1, Getting Started with Django 1.8
- The Creating a model mixin with URL-related methods recipe
- The Creating a model mixin to handle creation and modification dates recipe
- The Creating a model mixin to take care of meta tags recipe

- 第一章，Django 1.8入门中的让你的代码同时兼容Python 2.7和Python 3的技巧
- 创建一个拥有相对URL方法的模型Mixin
- 创建一个能够处理日期的创建和修改的模型Minix
- 创建一个可以处理元标签的模型Minxin

## 创建一个拥有相对URL方法的模型mixin
For every model that has its own page, it is good practice to define the `get_absolute_url()` method. This method can be used in templates and also in the Django admin site to preview the saved object. However, `get_absolute_url()` is ambiguous as it returns the URL path instead of the full URL. In this recipe, we will see how to create a model mixin that allows you to define either the URL path or the full URL by default, generate the other out of the box, and take care of the `get_absolute_url()` method that is being set.  

如果每个模型都要拥有自己的页面，那么最好的解决办法是定义`get_absolute_url()`方法。改方法可以在模板中使用，也可以用在Django的admin站点中预览保存的对象。不过，`get_absolute_url()`返回是模棱两可的，因为它返回的是URL路径，而不是完整的URL。在这个技法中，我们可以看如何创建一个允许你定义URL路径或者是定义完整URL的模型mixin，

### Getting ready 准备工作
If you haven't done it yet, create the utils package to save your mixins. Then, create the models.py file in the utils package (alternatively, if you create a reusable app, put the mixins in the base.py file in your app).  

如果你还没有完成它，那么你需要创建utils包来保存你的mixin。然后，在utils包中创建models.py文件（另外的选择是，如果你要创建一个可重复使用的应用，那么可以在你的应用中将mixin写入到文件base.py）。  

### How to do it… 

Execute the following steps one by one:  
一步步地执行下面的步骤：  

1. Add the following content to the models.py file of your utils package:  

添加以下内容到utils包中的models.py文件：  

```python
# utils/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import urlparse
from django.db import models
from django.contrib.sites.models import Site
from django.conf import settings


class UrlMixin(models.Model):
    """
    A replacement for get_absolute_url Models extending this mixin should have 
    either get_url or get_url_path implemented.
    get_absolute_url的替代品，模型扩展要这个mixin应该实现get_url或者get_url_path两者其一。
    """
    class Meta:
        abstract = True

    def get_url(self):
        if hasattr(self.get_url_path, "dont_recurse"):
            raise NotImplementedError
        try:
            path = self.get_url_path()
        except NotImplementedError:
            raise
        website_url = getattr(
            settings, "DEFAULT_WEBSITE_URL", "http://127.0.0.1:8000"
        )
        return website_url + path

    get_url.dont_recurse = True

    def get_url_path(self):
        if hasattr(self.get_url, "dont_recurse"):
            raise NotImplementedError
        try:
            url = self.get_url()
        except NotImplementedError:
            raise
        bits = urlparse.urlparse(url)
        return urlparse.urlunparse(("", "") + bits[2:])

    get_url_path.dont_recurse = True

    def get_absolute_url(self):
        return self.get_url_path()
```

2. To use the mixin in your app, import it from the utils package, inherit the mixin in your model class, and define the get_url_path() method as follows:  

2. 要在自己的应用中使用这个mixin，你可以从utils包中把它导入进去，在自定义的模型类中继承这个mixin，然后定义 get_url_path()方法，一如下面所示：  

```python
# demo_app/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.core.urlresolvers import reverse
from django.utils.encoding import \
    python_2_unicode_compatible

from utils.models import UrlMixin


@python_2_unicode_compatible
class Idea(UrlMixin):
    title = models.CharField(_("Title"), max_length=200)
    # ...
    get_url_path(self):
        return reverse("idea_details", kwargs={
            "idea_id": str(self.pk),
        })
```

3. If you check this code in the staging or production environment or run a local server with a different IP or port than the defaults, set DEFAULT_WEBSITE_URL in your local settings (without the trailing slash), as follows:  

3. 如果你是在过渡环境或者是生成环境中检验该代码，又或者是运行一个使用了不同于默认的IP、端口，那么你可以在本地的配置中设置DEFAULT_WEBSITE_URL（没有反斜杠），一如下面所示：  

```python
# settings.py
# …
DEFAULT_WEBSITE_URL = "http://www.example.com"
```

### How it works…

The UrlMixin class is an abstract model that has three methods: get_url(), get_url_path(), and get_absolute_url(). The get_url() or get_url_path() methods are expected to be overwritten in the extended model class, for example, Idea. You can define get_url(), which is the full URL of the object, and then get_url_path() will strip it to the path. You can also define get_url_path(), which is the absolute path of the object, and then get_url() will prepend the website URL to the beginning of the path. The get_absolute_url() method will mimic the get_url_path() method.  

UrlMixin类是一个拥有是三个方法点抽象模型：et_url(), get_url_path(),和get_absolute_url()。get_url()和get_url_path()方法期望在扩展的模型类中被重写，比如，Idea。你可以定义get_url()，它是对象的完整URL，然后是get_url_path()会把这个URL转换为路径。你也可以定义get_url_path()，它是对象的绝对路径，接着get_url()会将网站的URL加到路径的起始处。get_absolute_url()方法模仿了get_url_path()方法。  

>#### Tip
>The rule of thumb is to always overwrite the get_url_path() method.  

>#### 提示
>推荐的规则是保持对get_url_path()方法的重写。  

In the templates, use <a href="{{ idea.get_url_path }}">{{ idea.title }}</a> when you need a link of an object in the same website. Use <a href="{{ idea.get_url }}">{{ idea.title }}</a> for the links in e-mails, RSS feeds, or APIs.

在模板中，当你需要在相同的网站中使用一个对象的链接时，可以使用 <a href="{{ idea.get_url_path }}">{{ idea.title }}</a>。对电子邮件，RSS订阅，或者API中的链接可以使用<a href="{{ idea.get_url }}">{{ idea.title }}</a>。  

The default get_absolute_url() method will be used in the Django model administration for the View on site functionality and might also be used by some third-party Django apps.  

默认的get_absolute_url()方法将被用在对站点功能视图的Django模型管理上，同时还被第三方Django应用所使用。  

### See also 参见

- The Using model mixins recipe
- The Creating a model mixin to handle creation and modification dates recipe
- The Creating a model mixin to take care of meta tags recipe
- The Creating a model mixin to handle generic relations recipe

## Creating a model mixin to handle creation and modification dates

It is a common behavior to have timestamps in your models for the creation and modification of your model instances. In this recipe, we will see how to create a simple model mixin that saves the creation and modification dates and times for your model. Using such a mixin will ensure that all the models use the same field names for the timestamps and have the same behavior.  

在模型中味了创建和修改模型实例，使用时间戳是一个常见的行为。这此技法中，我们会看到如何使用一个简单的模型mixin来保存模型的创建和修改的日期和时间。使用此类mixin要保证所有的模型都对时间戳使用了相同的字段字段名称，以及相同的行为。  

### Getting ready

If you haven't done this yet, create the utils package to save your mixins. Then, create the models.py file in the utils package.  

如果你还没有这样的话，请创建utils包以保存mixin。然后再utils包中创建models.py文件。  

### How to do it…

Open the models.py file of your utils package and insert the following content there:  

在utils保中的models.py文件，然后插入以下内容：  

```python
# utils/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.timezone import now as timezone_now


class CreationModificationDateMixin(models.Model):
    """
    Abstract base class with a creation and modification
    date and time
    """

    created = models.DateTimeField(
    _("creation date and time"),
    editable=False,
    )

    modified = models.DateTimeField(
    _("modification date and time"),
    null=True,
    editable=False,
    )
    def save(self, *args, **kwargs):
        if not self.pk:
            self.created = timezone_now()
        else:
            # To ensure that we have a creation data always, 为了保证我们一直拥有创建数据，我们添加了此行
            # we add this one
        if not self.created:
            self.created = timezone_now()

            self.modified = timezone_now()

            super(CreationModificationDateMixin, self).\
            save(*args, **kwargs)
            save.alters_data = True

    class Meta:
        abstract = True
```

### How it works… 实现原理

The CreationModificationDateMixin class is an abstract model, which means that extending model classes will create all the fields in the same database table, that is, there will be no one-to-one relationships that make the table difficult to handle. This mixin has two date-time fields and the save() method that will be called when saving the extended model. The save() method checks whether the model has no primary key, which is the case of a new not-yet-saved instance. In this case, it sets the creation date to the current date and time. If the primary key exists, the modification date is set to the current date and time.  

CreationModificationDateMixin类是一个抽象模型，这意味着扩展模型类将在在相同的数据库表中创建所有的字段，即，不会存在让表难以处理的一对一关系。该mixin拥有两个日期字段，和保存扩展模型时会被调用到的save()方法。save()方法检查模型是否不存在主键，这是一种新创建但是未保存实例的情况。此种情况下，设置创建日期为当前日期和时间。如果主键存在，那么修改日期则被设置为当前日期和时间。  

Alternatively, instead of the save() method, you can use the auto_now_add and auto_now attributes for the created and modified fields, which will add creation and modification timestamps automatically.  

作为选择，与使用save()方法相反，你可以使用auto_now_add和auto_now属性来创建和修改字段，它可以自动地添加创建、修改时间戳。  

### See also 参见

- The Using model mixins recipe
- The Creating a model mixin to take care of meta tags recipe
- The Creating a model mixin to handle generic relations recipe

- 使用模型mixin技法
- 
- 

## Creating a model mixin to take care of meta tags 创建处理元标签的模型mixin

If you want to optimize your site for search engines, you need to not only set the semantic markup for each page but also the appropriate meta tags. For maximum flexibility, you need to have a way to define specific meta tags for each object, which has its own page on your website. In this recipe, we will see how to create a model mixin for the fields and methods related to the meta tags.  

如果你想为搜索引擎优化自己的网站，那么你需要的不仅是为每个页面设置语意装饰，还要设置适当的meta标签。考虑到最大的灵活性，你需要实现一种为每个对象定义制定元标签的办法，而这些对象在网站上都拥有自己的页面。在该技法中，我们可以看到如何为关联到元标签的字段和方法创建一个模型mixin。  

### Getting ready 准备工作

As seen in the previous recipes, make sure that you have the utils package for your mixins. Open the models.py file from this package in your favorite editor.  

就想再前面技法中所见到的那样，要确保你已经为mixin建立了utils包。再自己喜欢的编辑器中从这个包打开models.py文件。  

### How to do it… 具体做法

Put the following content in the models.py file:  

在models.py文件中加入以下内容：  

```python
# utils/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.template.defaultfilters import escape
from django.utils.safestring import mark_safe


class MetaTagsMixin(models.Model):
    """
    Abstract base class for meta tags in the <head> section
    用于head区域内元标签的抽象基类
    """
    meta_keywords = models.CharField(
    _("Keywords"),
    max_length=255,
    blank=True,
    help_text=_("Separate keywords by comma."),
    )
    meta_description = models.CharField(
    _("Description"),
    max_length=255,
    blank=True,
    )
    
    meta_author = models.CharField(
    _("Author"),
    max_length=255,
    blank=True,
    )

    meta_copyright = models.CharField(
    _("Copyright"),
    max_length=255,
    blank=True,
    )

    class Meta:
        abstract = True

    def get_meta_keywords(self):
        tag = ""
        if self.meta_keywords:
        tag = "<meta name="keywords" content="%s" />\n" %\
          escape(self.meta_keywords)
        return mark_safe(tag)

    def get_meta_description(self):
        tag = ""
        if self.meta_description:
        tag = "<meta name="description" content="%s" />\n" %\
          escape(self.meta_description)
        return mark_safe(tag)

    def get_meta_author(self):
        tag = ""
        if self.meta_author:
        tag = "<meta name="author" content="%s" />\n" %\
          escape(self.meta_author)
        return mark_safe(tag)

    def get_meta_copyright(self):
        tag = ""
        if self.meta_copyright:
        tag = "<meta name="copyright" content="%s" />\n" %\
          escape(self.meta_copyright)
        return mark_safe(tag)

    def get_meta_tags(self):
        return mark_safe("".join((
            self.get_meta_keywords(),
            self.get_meta_description(),
            self.get_meta_author(),
            self.get_meta_copyright(),
            )))
```

### How it works…

This mixin adds four fields to the model that extends from it: meta_keywords, meta_description, meta_author, and meta_copyright. The methods to render the meta tags in HTML are also added.  

该mixin为扩展自己的模型添加了四个字段：meta_keywords, meta_description, meta_author,和meta_copyright。该方法在HTMl中渲染的元标签也被添加了。  

If you use this mixin in a model such as Idea, which is shown in the first recipe of this chapter, then you can put the following in the HEAD section of your detail page template to render all the meta tags:  

如果你在一个模型内部使用mixin，比如Idea，它出自本章的第一个技法中，然后你可以再详情页面模板中将下面内容放到HEAD区域以便渲染所有的原标签：  

```
{{ idea.get_meta_tags }}
```

You can also render a specific meta tag using the following line:  

你也可以使用下面的行渲染一个指定的元标签：  

```
{{ idea.get_meta_description }}
```

As you may have noticed from the code snippet, the rendered meta tags are marked as safe, that is, they are not escaped and we don't need to use the safe template filter. Only the values that come from the database are escaped in order to guarantee that the final HTML is well-formed.  

你可能注意到了，再代码片段中，渲染元标签被标记为安全，即，它们未被转义，而且我们不需要使用安全模板过滤器。唯一的来自数据库的值也被转义了，以便保证最终的HTMl正确显示。  

### See also 参见

- The Using model mixins recipe
- The Creating a model mixin to handle creation and modification dates recipe
- The Creating a model mixin to handle generic relations recipe

- 使用模型mixin技法
- 创建模型mixin处理日期创建和修改技法
- 创建模型mixin处理通用关系技法

## Creating a model mixin to handle generic relations 创建模型mixin以处理日期创建和修改

Besides normal database relationships such as a foreign-key relationship or many-to-many relationship, Django has a mechanism to relate a model to an instance of any other model. This concept is called generic relations. For each generic relation, there is a content type of the related model that is saved as well as the ID of the instance of this model.  

除了常规的数据关系，比如外键关系或者多对多关系，Django还提供了一种关联一个模型到任何其他模型实例的机制。这个概念称作通用关系。对于每个通用关系而言，都有一个关联模型的内容类型，该用内容类型用来保存这个模型实例的ID。  

In this recipe, we will see how to generalize the creation of generic relations in the model mixins.  

在该技法中，我们看到了如何在模型mixin中归纳通用关系的创建。  

### Getting ready

For this recipe to work, you need to have the contenttypes app installed. It should be in the INSTALLED_APPS directory by default, as shown in the following:  

为了让该技法发挥作用，你需要安装应用contenttypes。如下所示，默认，它应该出现INSTALLED_APPS目录中：  

```python
# settings.py
INSTALLED_APPS = (
    # …
    "django.contrib.contenttypes",
)
```

Again, make sure that you have the utils package for your model mixins already created.  

请再次确保你已经为模型mixin创建了utils包。  

### How to do it… 具体做法

Open the models.py file in the utils package in a text editor and insert the following content there:  

在文本编辑器中打开utils包中的models.py文件，然后在文件中插入以下内容：  

```python
# utils/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from django.core.exceptions import FieldError


def object_relation_mixin_factory(
  prefix=None,
  prefix_verbose=None,
  add_related_name=False,
  limit_content_type_choices_to={},
  limit_object_choices_to={},
  is_required=False,
):
  """
    returns a mixin class for generic foreign keys using
    "Content type - object Id" with dynamic field names.
    This function is just a class generator

    使用包含了动态字段名称的“Content type - object Id”为通用关系外键返回一个mixin类。
    该函数仅作为一个类生成器。

    Parameters:
    prefix : a prefix, which is added in front of the fields
    prefix_verbose :    a verbose name of the prefix, used to
                        generate a title for the field column
                        of the content object in the Admin.
    add_related_name :  a boolean value indicating, that a
                        related name for the generated content
                        type foreign key should be added. This
                        value should be true, if you use more
                        than one ObjectRelationMixin in your model.

    参数：
    prefix： 添加到字段之前的一个前缀
    prefix_verbose： 前缀的冗长名，用来生成Admin中字段列的

    The model fields are created like this:
    模型字段可以像这样创建：

    <<prefix>>_content_type :   Field name for the "content type"
    <<prefix>>_object_id :      Field name for the "object Id"
    <<prefix>>_content_object : Field name for the "content object"

    """
    p = ""
    if prefix:
      p = "%s_" % prefix

    content_type_field = "%scontent_type" % p
    object_id_field = "%sobject_id" % p
    content_object_field = "%scontent_object" % p


    class TheClass(models.Model):
      class Meta:
        abstract = True

    if add_related_name:
      if not prefix:
        raise FieldError("if add_related_name is set to True,"
          "a prefix must be given")
        related_name = prefix
    else:
      related_name = None


    optional = not is_required

    ct_verbose_name = (
      _("%s's type (model)") % prefix_verbose
      if prefix_verbose
      else _("Related object's type (model)")
    )

    content_type = models.ForeignKey(
      ContentType,
      verbose_name=ct_verbose_name,
      related_name=related_name,
      blank=optional,
      null=optional,
      help_text=_("Please select the type (model) for the relation, you want to build."),
      limit_choices_to=limit_content_type_choices_to,
    )

    fk_verbose_name = (prefix_verbose or _("Related object"))

    object_id = models.CharField(
      fk_verbose_name,
      blank=optional,
      null=False,
      help_text=_("Please enter the ID of the related object."),
      max_length=255,
      default="",  # for south migrations
    )
    object_id.limit_choices_to = limit_object_choices_to
    # 可使用MyModel._meta.get_field("object_id").limit_choices_to重新取回

    content_object = generic.GenericForeignKey(
      ct_field=content_type_field,
      fk_field=object_id_field,
    )

    TheClass.add_to_class(content_type_field, content_type)
    TheClass.add_to_class(object_id_field, object_id)
    TheClass.add_to_class(content_object_field, content_object)

    return TheClass
```

1. The following is an example of how to use two generic relationships in your app (put this code in demo_app/models.py), as shown in the following:  

1. 如下所示，下面是一个如何在应用中使用两个通用关系的例子（将此代码放到 demo_app/models.py中）：  

```python
# demo_app/models.py
# -*- coding: UTF-8 -*-
from __future__ import nicode_literals
from django.db import models
from utils.models import object_relation_mixin_factory
from django.utils.encoding import python_2_unicode_compatible

FavoriteObjectMixin = object_relation_mixin_factory(
    is_required=True,
)

OwnerMixin = object_relation_mixin_factory(
    prefix="owner",
    prefix_verbose=_("Owner"),
    add_related_name=True,
    limit_content_type_choices_to={
        'model__in': ('user', 'institution')
    },
    is_required=True,
)

@python_2_unicode_compatible
class Like(FavoriteObjectMixin, OwnerMixin):
    class Meta:
        verbose_name = _("Like")
        verbose_name_plural = _("Likes")

    def __str__(self):
        return _("%(owner)s likes %(obj)s") % {
            "owner": self.owner_content_object,
            "obj": self.content_object,
        }
```

### How it works… 实现原理

As you can see, this snippet is more complex than the previous ones. The object_relation_mixin_factory object is not a mixin itself; it is a function that generates a model mixin, that is, an abstract model class to extend from. The dynamically created mixin adds the content_type and object_id fields and the content_object generic foreign key that points to the related instance.  

如你所见，这个片段比之前的那个更为复杂。对象object_relation_mixin_factory并不是mixin自身；它是一个生成模型mixin的函数，即，一个可以被扩展的抽象模型类。动态创建的mixin添加了content_type和object_id，以及指向关联实例的通用外键content_object。  

Why couldn't we just define a simple model mixin with these three attributes? A dynamically generated abstract class allows us to have prefixes for each field name; therefore, we can have more than one generic relation in the same model. For example, the Like model, which was shown previously, will have the content_type, object_id, and content_object fields for the favorite object and owner_content_type, owner_object_id, and owner_content_object for the one (user or institution) who liked the object.   

为什么我们不可以定义一个包含着三个属性简单模型mixin？因为，动态生成的抽象类允许我们为每个字段名称添加前缀；因此，我们可以在相同的模型中拥有不止一个通用关系。例如，之前出现的Like模型，它让favorite对象拥有content_type, object_id, 和content_object字段；关注这个对象的（用户或者名人）拥有owner_content_type, owner_object_id,和owner_content_object字段。  

The object_relation_mixin_factory() function adds a possibility to limit the content type choices by the limit_content_type_choices_to parameter. The preceding example limits the choices for owner_content_type only to the content types of the User and Institution models. Also, there is the limit_object_choices_to parameter that can be used by custom form validation to limit the generic relations only to specific objects, for example, the objects with published status.  

object_relation_mixin_factory()函数通过参数limit_content_type_choices_to加入了限制内容类型选择的可能性。上面的的例子，仅对User模型和Institution模型的内容类型执行了owner_content_type的选择限制。而且，

### See also

- The Creating a model mixin with URL-related methods recipe
- The Creating a model mixin to handle creation and modification dates recipe
- The Creating a model mixin to take care of meta tags recipe
- The Implementing the Like widget recipe in Chapter 4, Templates and JavaScript


## Handling multilingual fields 处理多语言字段

Django uses the internationalization mechanism to translate verbose strings in the code and templates. However, it's up to the developer to decide how to implement the multilingual content in the models. There are several third-party modules that handle translatable model fields; however, I prefer the simple solution that will be introduced to you in this recipe.  

Django使用国际化机制在代码和数据中将冗余字符串翻译过来。不过，决定如何在模型中实现多语言内容则交给开发者选择。有很多个处理可翻译模型字段的第三方摩卡；不过，我个人偏爱的简单解决方案会在此技法中介绍给你。  

The advantages of the approach that you will learn about are as follows:  

你要了解这种方法的好处如下：  

- It is straightforward to define multilingual fields in the database
- It is simple to use the multilingual fields in database queries
- You can use contributed administration to edit models with the multilingual fields without additional modifications
- If you need it, you can easily show all the translations of an object in the same template
- You can use database migrations to add or remove languages

- 它简单了当在数据库中定义多语言字段
- 在数据库查询中很简单的使用多语言字段
- 你可以使用admin应用编辑包含多语言字段的模型而无需额外的改动
- 如果有需要的话，你可以在相同的模板中显示一个对象的全部翻译内容
- 你可以使用数据库迁移添加或者删除语言

### Getting ready 准备工作

Do you have the utils package created? You will now need a new fields.py file for the custom model fields there.  

你已经创建了utils包吗？现在你需为定制模型字段创建一个文件fields.py。  

### How to do it… 实现原理

Execute the following steps to define the multilingual character field and multilingual text field:  

执行下面的步骤以定义多语言字符字段和多语言文本字段：  

1. Open the fields.py file and create the multilingual character field as follows:  

1. 如下，打开fields.py文件，然后创建多语言字符字段：  

```python
# utils/fields.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.conf import settings
from django.db import models
from django.utils.translation import get_language
from django.utils.translation import string_concat

class MultilingualCharField(models.CharField):

  def __init__(self, verbose_name=None, **kwargs):

    self._blank = kwargs.get("blank", False)
    self._editable = kwargs.get("editable", True)

    super(MultilingualCharField, self).\
      __init__(verbose_name, **kwargs)

  def contribute_to_class(self, cls, name,
    virtual_only=False):
    # generate language specific fields dynamically
    if not cls._meta.abstract:
      for lang_code, lang_name in settings.LANGUAGES:
        if lang_code == settings.LANGUAGE_CODE:
          _blank = self._blank
        else:
          _blank = True

        localized_field = models.CharField(
          string_concat(self.verbose_name, 
            " (%s)" % lang_code),
              name=self.name,
                primary_key=self.primary_key,
                max_length=self.max_length,
                unique=self.unique,
                blank=_blank,
                null=False,
                # we ignore the null argument!
                db_index=self.db_index,
                rel=self.rel,
                default=self.default or "",
                editable=self._editable,
                serialize=self.serialize,
                choices=self.choices,
                help_text=self.help_text,
                db_column=None,
                db_tablespace=self.db_tablespace
        )
        localized_field.contribute_to_class(
          cls,
          "%s_%s" % (name, lang_code),
        )

        def translated_value(self):
          language = get_language()
          val = self.__dict__["%s_%s" % (name, language)]
          if not val:
            val = self.__dict__["%s_%s" % \
              (name, settings.LANGUAGE_CODE)]
              return val

      setattr(cls, name, property(translated_value))
```

In the same file, add an analogous multilingual text field. The differing parts are highlighted in the following code:  

在相同文件中，添加一个模拟多语言文本字段。在下面的代码中不同的部分被高亮表示出来了：  

```python
class MultilingualTextField(models.TextField):

  def __init__(self, verbose_name=None, **kwargs):


    self._blank = kwargs.get("blank", False)
    self._editable = kwargs.get("editable", True)

    super(MultilingualTextField, self).\
      __init__(verbose_name, **kwargs)

    def contribute_to_class(self, cls, name, virtual_only=False):
      # generate language specific fields dynamically
      if not cls._meta.abstract:
        for lang_code, lang_name in settings.LANGUAGES:
          if lang_code == settings.LANGUAGE_CODE:
            _blank = self._blank
          else:
            _blank = True

            localized_field = models.TextField(
              string_concat(self.verbose_name, 
                " (%s)" % lang_code),
              name=self.name,
              primary_key=self.primary_key,
              max_length=self.max_length,
              unique=self.unique,
              blank=_blank,
              null=False,
              # we ignore the null argument!
              db_index=self.db_index,
              rel=self.rel,
              default=self.default or "",
              editable=self._editable,
              serialize=self.serialize,
              choices=self.choices,
              help_text=self.help_text,
              db_column=None,
              db_tablespace=self.db_tablespace
            )
            localized_field.contribute_to_class(
              cls,
                "%s_%s" % (name, lang_code),
            )

        def translated_value(self):
          language = get_language()
          val = self.__dict__["%s_%s" % (name, language)]
          if not val:
            val = self.__dict__["%s_%s" % \
              (name, settings.LANGUAGE_CODE)]
            return val

        setattr(cls, name, property(translated_value))
```

Now, we'll consider an example of how to use the multilingual fields in your app, as shown in the following:  

如下所示，现在我要考虑一个在应用中如何使用多语言字段的例子：  

1. First, set multiple languages in your settings:  

1. 首先，在settings中设置多语言：  

```python
# myproject/settings.py
# -*- coding: UTF-8 -*-
# …
LANGUAGE_CODE = "en"

LANGUAGES = (
    ("en", "English"),
    ("de", "Deutsch"),
    ("fr", "Français"),
    ("lt", "Lietuvi kalba"),
)
```

2. Then, create the multilingual fields for your model, as follows:  

2. 如下，然后为模型创建多语言字段：  

```python
# demo_app/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import \
    python_2_unicode_compatible

from utils.fields import MultilingualCharField
from utils.fields import MultilingualTextField

@python_2_unicode_compatible
class Idea(models.Model):
    title = MultilingualCharField(
        _("Title"),
        max_length=200,
    )
    description = MultilingualTextField(
        _("Description"),
        blank=True,
    )

    class Meta:
        verbose_name = _("Idea")
        verbose_name_plural = _("Ideas")

    def __str__(self):
        return self.title
```

### How it works… 实现原理

The example of Idea will create a model that is similar to the following:  

例子Idea会创建一个类似于下面的模型：   

```python
class Idea(models.Model):
  title_en = models.CharField(
    _("Title (en)"),
    max_length=200,
  )
  title_de = models.CharField(
    _("Title (de)"),
    max_length=200,
    blank=True,
  )
  title_fr = models.CharField(
    _("Title (fr)"),
    max_length=200,
    blank=True,
  )
  title_lt = models.CharField(
    _("Title (lt)"),
    max_length=200,
    blank=True,
  )
  description_en = models.TextField(
    _("Description (en)"),
    blank=True,
  )
  description_de = models.TextField(
    _("Description (de)"),
    blank=True,
  )
  description_fr = models.TextField(
    _("Description (fr)"),
    blank=True,
  )
  description_lt = models.TextField(
    _("Description (lt)"),
    blank=True,
  )
```

In addition to this, there will be two properties: title and description that will return the title and description in the currently active language.  

此外，这里有两个属性：title和description，它们将返回当前活动语言中的标题和描述。  

The MultilingualCharField and MultilingualTextField fields will juggle the model fields dynamically, depending on your LANGUAGES setting. They will overwrite the contribute_to_class() method that is used when the Django framework creates the model classes. The multilingual fields dynamically add character or text fields for each language of the project. Also, the properties are created in order to return the translated value of the currently active language or the main language by default.  

根据LANGUAGES的设置，The MultilingualCharField 和 MultilingualTextField 字段会自动地同时处理模型字段。它们在Django框架创建模型类时，会重写所使用的contribute_to_class()方法。多语言字段动态地对项目中的每种语言添加字符或者文本字段。而且，创建的属性会按照顺序返回当前活动语言或者默认主语言被翻译过的值。  

For example, you can have the following in the template:  

例如，你可以在模板中添加下面的内容：  

```html
<h1>{{ idea.title }}</h1>
<div>{{ idea.description|urlize|linebreaks }}</div>
```

This will show the text in English, German, French, or Lithuanian, depending on the currently selected language. However, it will fall back to English if the translation doesn't exist.  



Here is another example. If you want to have your QuerySet ordered by the translated titles in the view, you can define it as follows:  

这是另外一个例子。如果你想要

```python
qs = Idea.objects.order_by("title_%s" % request.LANGUAGE_CODE)
```

## Using migrations 使用迁移

It is not true that once you have created your database structure, it won't change in the future. As development happens iteratively, you can get updates on the business requirements in the development process and you will need to perform database schema changes along the way. With the Django migrations, you don't need to change the database tables and fields manually, as most of it is done automatically using the command-line interface.  

### Getting ready 准备工作

Activate your virtual environment in the command-line tool.  

在命令行中激活你的虚拟环境。  

### How to do it… 具体做法

To create the database migrations, take a look at the following steps:  

要创建数据库迁移，先来看看以下几个步骤：  

1. When you create models in your new demo_app app, you need to create an initial migration that will create the database tables for your app. This can be done using the following command:  

```shell
(myproject_env)$ python manage.py makemigrations demo_app
```

2. The first time that you want to create all the tables for your project, run the following command:

```shell
(myproject_env)$ python manage.py migrate
```

It executes the usual database synchronization for all apps that have no database migrations, and in addition to this, it migrates all apps that have the migrations set. Also, run this command when you want to execute the new migrations for all your apps.  

3. If you want to execute the migrations for a specific app, run the following command:  

```shell
(myproject_env)$ python manage.py migrate demo_app
```

4. If you make some changes in the database schema, you have to create a migration for that schema. For example, if we add a new subtitle field to the Idea model, we can create the migration using the following command:  

```shell
(myproject_env)$ python manage.py makemigrations --name \
subtitle_added demo_app
```

5. To create a data migration that modifies the data in the database table, we can use the following command:  

```shell
(myproject_env)$ python manage.py makemigrations --empty \ --name populate_subtitle demo_app
```

This creates a skeleton data migration, which you need to modify and add data manipulation to it before applying.  

6. To list all the available applied and unapplied migrations, run the following command:  

```shell
(myproject_env)$ python manage.py migrate --list
```

The applied migrations will be listed with a `[X]` prefix.  

To list all the available migrations for a specific app, run the following command:  

```shell
(myproject_env)$ python manage.py migrate --list demo_app
```

### How it works…

Django migrations are instruction files for the database migration mechanism. The instruction files inform us which database tables to create or remove; which fields to add or remove; and which data to insert, update, or delete.  
 
There are two types of migrations in Django. One is schema migration and the other is data migration. Schema migration should be created when you add new models, or add or remove fields. Data migration should be used when you want to fill the database with some values or massively delete values from the database. Data migrations should be created using a command in the command-line tool and then programmed in the migration file. Migrations for each app are saved in their migrations directories. The first migration will be usually called 0001_initial.py, and the other migrations in our example app will be called 0002_subtitle_added.py and 0003_populate_subtitle.py. Each migration gets a number prefix that is automatically incremented. For each migration that is executed, there is an entry that is saved in the django_migrations database table.  

It is possible to migrate back and forth by specifying the number of the migration to which we want to migrate to, as shown in the following:  

```shell
(myproject_env)$ python manage.py migrate demo_app 0002
```

If you want to undo all the migrations for a specific app, you can do so using the following command:  

```shell
(myproject_env)$ python manage.py migrate demo_app zero
```

>#### Tip
>Do not commit your migrations to version control until you have tested the forward and backward migration process and you are sure that they will work well in other development and public website environments.  

### See also

- The Handling project dependencies with pip and Including external dependencies in your project recipes in Chapter 1, Getting Started with Django 1.8
- The Changing a foreign key to the many-to-many field recipe

## Switching from South migrations to Django migrations

If you, like me, have been using Django since before database migrations existed in the core functionality, that is, before Django 1.7; you have, more than likely, used third-party South migrations before. In this recipe, you will learn how to switch your project from South migrations to Django migrations.  

### Getting ready

Make sure that all apps and their South migrations are up to date.  

### How to do it…

Execute the following steps:  

1. Migrate all your apps to the latest South migrations, as follows:  

```shell
(myproject_env)$ python manage.py migrate
```

2. Remove south from INSTALLED_APPS in the settings.
3. For each app with South migrations, delete the migration files and only leave the migrations directories.
4. Create new migration files with the following command:  

```shell
(my_project)$ python manage.py makemigrations
```

5. Fake the initial Django migrations as the database schema has already been set correctly:  

```shell
(my_project)$ python manage.py migrate --fake-initial
```

6. If you have any circular foreign keys in the apps (that is, two models in different apps pointing to each other with a foreign key or many-to-many relation), separately apply the fake initial migrations to these apps:  

```shell
(my_project)$ python manage.py migrate --fake-initial demo_app
```

### How it works…

There is no conflict in the database when switching to the new way of dealing with the database schema changes as the South migration history is saved in the south_migrationhistory database table; whereas, the Django migration history is saved in the django_migrations database table. The only problem are the migration files that have different syntax and, therefore, the South migrations need to be completely replaced with the Django migrations.  

Therefore, at first, we delete the South migration files. Then, the makemigrations command recognizes the empty migrations directories and creates new initial Django migrations for each app. Once these migrations are faked, the further Django migrations can be created and applied.  

### See also 参见

- The Using migrations recipe
- The Changing a foreign key to the many-to-many field recipe

- 使用迁移技法
- 将一个外键改变为多对多字段技法

## Changing a foreign key to the many-to-many field 将一个外键改变为多对多字段

This recipe is a practical example of how to change a many-to-one relation to many-to-many relation, while preserving the already existing data. We will use both schema and data migrations for this situation.  

该技法是一个如何将多对一关系改变为多对多关系，而且保留已有数据的实际例子。对于此种情况，我们同时使用表迁移和数据迁移。  

### Getting ready 准备工作

Let's consider that you have the Idea model with a foreign key pointing to the Category model, as follows:  

如下，我们假设你拥有一个包含指向了Category模型的外键的Idea模型：  

```python
# demo_app/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import python_2_unicode_compatible

@python_2_unicode_compatible
class Category(models.Model):
    title = models.CharField(_("Title"), max_length=200)

    def __str__(self):
        return self.title

@python_2_unicode_compatible
class Idea(models.Model):
    title = model.CharField(_("Title"), max_length=200)
    category = models.ForeignKey(Category,
        verbose_name=_("Category"), null=True, blank=True)

    def __str__(self):
        return self.title
```

The initial migration should be created and executed using the following commands:  

使用下面的命令可以创建并执行初始化迁移：  

```shell
(myproject_env)$ python manage.py makemigrations demo_app
(myproject_env)$ python manage.py migrate demo_app
```

### How to do it… 具体做法

The following steps will teach you how to switch from a foreign key relation to many-to-many relation, while preserving the already existing data:  

下面的步骤会教授你如何从一个外键关系切换到多对多关系，同时保留已经存在的数据：  

1. Add a new many-to-many field called categories, as follows:  

1. 如下，添加一个称作categories的多对多字段：  

```python
# demo_app/models.py
@python_2_unicode_compatible
class Idea(models.Model):
    title = model.CharField(_("Title"), max_length=200)
    category = models.ForeignKey(Category,
        verbose_name=_("Category"),
        null=True,
        blank=True,
    )
    categories = models.ManyToManyField(Category, 
        verbose_name=_("Categories"),
        blank=True, 
        related_name="ideas",
    )
```

2. Create and run a schema migration in order to add the new field to the database, as shown in the following:  

2. 如下所示，创建并运行表迁移以便对数据库添加新字段：  

```shell
(myproject_env)$ python manage.py makemigrations demo_app \
--name categories_added
(myproject_env)$ python manage.py migrate demo_app
```

3. Create a data migration to copy categories from the foreign key to the many-to-many field, as follows:  

3. 如下，创建一个数据迁移以便将外键的categories拷贝为多对多字段：  

```shell
(myproject_env)$ python manage.py makemigrations --empty \
--name copy_categories demo_app
```

4. Open the newly created migration file (demo_app/migrations/0003_copy_categories.py) and define the forward migration instructions, as shown in the following:  

4. 打开新近创建的迁移文件（demo_app/migrations/0003_copy_categories.py），定义前向迁移命令，一如下面所示：  

```python
# demo_app/migrations/0003_copy_categories.py
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from django.db import models, migrations


def copy_categories(apps, schema_editor):
    Idea = apps.get_model("demo_app", "Idea")
    for idea in Idea.objects.all():
        if idea.category:
            idea.categories.add(idea.category)

class Migration(migrations.Migration):

    dependencies = [
        ('demo_app', '0002_categories_added'),
    ]

    operations = [
        migrations.RunPython(copy_categories),
    ]
```

5. Run the following data migration:  

5. 运行下面的数据迁移：  

```shell
(myproject_env)$ python manage.py migrate demo_app
```

6. Delete the foreign key field category in the models.py file:  

6. 在models.py文件中删除外键字段category：  

```python
# demo_app/models.py
@python_2_unicode_compatible
class Idea(models.Model):
    title = model.CharField(_("Title"), max_length=200)
    categories = models.ManyToManyField(Category,
        verbose_name=_("Categories"),
        blank=True,
        related_name="ideas",
    )
```

Create and run a schema migration in order to delete the categories field from the database table, as follows:   

如下，创建并运行一个表迁移以便从数据库表中删除categories字段：  

```shell
(myproject_env)$ python manage.py schemamigration \
--name delete_category demo_app
(myproject_env)$ python manage.py migrate demo_app
```

### How it works…  实现原理

At first, we add a new many-to-many field to the Idea model. Then, we copy the existing relations from a foreign key relation to the many-to-many relation. Lastly, we remove the foreign key relation.  

首先，我们对Idea模型添加了一个新的多对多字段。然后，我们从一个外键关系中将现有关系为多对多关系。最后，我们移除了外键关系。  

### See also 参见

- The Using migrations recipe
- The Switching from South migrations to Django migrations recipe

- 使用迁移技法
- 从South迁移切换到Django migrations技法


